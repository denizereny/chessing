<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LayoutOptimizer Unit Tests</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 10px;
    }
    .test-results {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-top: 20px;
    }
    .test-item {
      padding: 10px;
      margin: 5px 0;
      border-left: 4px solid #ddd;
      background: #fafafa;
    }
    .test-item.pass {
      border-left-color: #4CAF50;
      background: #f1f8f4;
    }
    .test-item.fail {
      border-left-color: #f44336;
      background: #fef1f0;
    }
    .summary {
      margin-top: 20px;
      padding: 15px;
      background: #e3f2fd;
      border-radius: 4px;
      font-weight: bold;
    }
    .summary.all-pass {
      background: #e8f5e9;
      color: #2e7d32;
    }
    .summary.has-fail {
      background: #ffebee;
      color: #c62828;
    }
  </style>
</head>
<body>
  <h1>LayoutOptimizer Unit Tests</h1>
  <div class="test-results" id="results"></div>

  <!-- Load dependencies -->
  <script src="../../js/adaptive-viewport/base-component.js"></script>
  <script src="../../js/adaptive-viewport/constants.js"></script>
  <script src="../../js/adaptive-viewport/types.js"></script>
  <script src="../../js/adaptive-viewport/layout-optimizer.js"></script>

  <script>
    // Test runner
    const results = [];
    let passCount = 0;
    let failCount = 0;

    function assert(condition, testName) {
      if (condition) {
        results.push({ name: testName, passed: true });
        passCount++;
      } else {
        results.push({ name: testName, passed: false });
        failCount++;
      }
    }

    function assertThrows(fn, testName) {
      try {
        fn();
        results.push({ name: testName + ' (expected error but none thrown)', passed: false });
        failCount++;
      } catch (error) {
        results.push({ name: testName, passed: true });
        passCount++;
      }
    }

    // Run tests
    console.log('=== LayoutOptimizer Unit Tests ===\n');

    // Test 1: Constructor with default configuration
    try {
      const optimizer = new LayoutOptimizer();
      assert(
        optimizer.getConfig('minBoardSize') === 280,
        'Test 1: Constructor sets default minBoardSize to 280'
      );
      assert(
        optimizer.getConfig('spacing') === 16,
        'Test 2: Constructor sets default spacing to 16'
      );
      assert(
        optimizer.getConfig('prioritizeBoard') === true,
        'Test 3: Constructor sets default prioritizeBoard to true'
      );
    } catch (error) {
      results.push({ name: 'Test 1-3: Constructor defaults', passed: false, error: error.message });
      failCount++;
    }

    // Test 2: Constructor with custom configuration
    try {
      const optimizer = new LayoutOptimizer({
        minBoardSize: 300,
        spacing: 20,
        prioritizeBoard: false
      });
      assert(
        optimizer.getConfig('minBoardSize') === 300,
        'Test 4: Constructor accepts custom minBoardSize'
      );
      assert(
        optimizer.getConfig('spacing') === 20,
        'Test 5: Constructor accepts custom spacing'
      );
      assert(
        optimizer.getConfig('prioritizeBoard') === false,
        'Test 6: Constructor accepts custom prioritizeBoard'
      );
    } catch (error) {
      results.push({ name: 'Test 4-6: Custom constructor', passed: false, error: error.message });
      failCount++;
    }

    // Test 3: calculateBoardSize with ample space
    try {
      const optimizer = new LayoutOptimizer();
      const boardSize = optimizer.calculateBoardSize(
        { width: 1920, height: 1080 },
        []
      );
      assert(
        boardSize.width >= 280 && boardSize.height >= 280,
        'Test 7: calculateBoardSize returns minimum board size'
      );
      assert(
        boardSize.width === boardSize.height,
        'Test 8: calculateBoardSize maintains square aspect ratio'
      );
    } catch (error) {
      results.push({ name: 'Test 7-8: calculateBoardSize', passed: false, error: error.message });
      failCount++;
    }

    // Test 4: calculateBoardSize with constrained space
    try {
      const optimizer = new LayoutOptimizer({ minBoardSize: 280 });
      const boardSize = optimizer.calculateBoardSize(
        { width: 400, height: 600 },
        []
      );
      assert(
        boardSize.width >= 280,
        'Test 9: calculateBoardSize respects minimum size in constrained space'
      );
      assert(
        boardSize.width <= 400,
        'Test 10: calculateBoardSize does not exceed available width'
      );
    } catch (error) {
      results.push({ name: 'Test 9-10: calculateBoardSize constrained', passed: false, error: error.message });
      failCount++;
    }

    // Test 5: calculateBoardSize with invalid dimensions
    try {
      const optimizer = new LayoutOptimizer();
      assertThrows(
        () => optimizer.calculateBoardSize({ width: -100, height: 500 }, []),
        'Test 11: calculateBoardSize throws error for negative dimensions'
      );
    } catch (error) {
      results.push({ name: 'Test 11: calculateBoardSize validation', passed: false, error: error.message });
      failCount++;
    }

    // Test 6: determineLayoutStrategy for wide viewport
    try {
      const optimizer = new LayoutOptimizer();
      const strategy = optimizer.determineLayoutStrategy(
        { width: 1920, height: 1080 },
        3
      );
      assert(
        strategy === 'horizontal',
        'Test 12: determineLayoutStrategy returns horizontal for wide viewport'
      );
    } catch (error) {
      results.push({ name: 'Test 12: determineLayoutStrategy wide', passed: false, error: error.message });
      failCount++;
    }

    // Test 7: determineLayoutStrategy for narrow viewport
    try {
      const optimizer = new LayoutOptimizer();
      const strategy = optimizer.determineLayoutStrategy(
        { width: 400, height: 800 },
        3
      );
      assert(
        strategy === 'vertical',
        'Test 13: determineLayoutStrategy returns vertical for narrow viewport'
      );
    } catch (error) {
      results.push({ name: 'Test 13: determineLayoutStrategy narrow', passed: false, error: error.message });
      failCount++;
    }

    // Test 8: determineLayoutStrategy for ultra-wide viewport
    try {
      const optimizer = new LayoutOptimizer();
      const strategy = optimizer.determineLayoutStrategy(
        { width: 3840, height: 1080 },
        3
      );
      assert(
        strategy === 'horizontal',
        'Test 14: determineLayoutStrategy returns horizontal for ultra-wide viewport'
      );
    } catch (error) {
      results.push({ name: 'Test 14: determineLayoutStrategy ultra-wide', passed: false, error: error.message });
      failCount++;
    }

    // Test 9: calculateElementPositions with empty array
    try {
      const optimizer = new LayoutOptimizer();
      const positions = optimizer.calculateElementPositions(
        [],
        'horizontal',
        { x: 0, y: 0, width: 500, height: 500 }
      );
      assert(
        positions.size === 0,
        'Test 15: calculateElementPositions returns empty map for empty array'
      );
    } catch (error) {
      results.push({ name: 'Test 15: calculateElementPositions empty', passed: false, error: error.message });
      failCount++;
    }

    // Test 10: validateLayout with valid configuration
    try {
      const optimizer = new LayoutOptimizer();
      const config = {
        boardSize: { width: 400, height: 400 },
        boardPosition: { x: 10, y: 10, width: 400, height: 400, transform: '', zIndex: 1 },
        elementPositions: new Map(),
        layoutStrategy: 'horizontal',
        requiresScrolling: false,
        scrollContainers: []
      };
      const result = optimizer.validateLayout(config);
      assert(
        result.valid === true,
        'Test 16: validateLayout returns valid for correct configuration'
      );
      assert(
        result.errors.length === 0,
        'Test 17: validateLayout returns no errors for correct configuration'
      );
    } catch (error) {
      results.push({ name: 'Test 16-17: validateLayout valid', passed: false, error: error.message });
      failCount++;
    }

    // Test 11: validateLayout with invalid board size
    try {
      const optimizer = new LayoutOptimizer({ minBoardSize: 280 });
      const config = {
        boardSize: { width: 200, height: 200 },
        boardPosition: { x: 10, y: 10, width: 200, height: 200, transform: '', zIndex: 1 },
        elementPositions: new Map(),
        layoutStrategy: 'horizontal',
        requiresScrolling: false,
        scrollContainers: []
      };
      const result = optimizer.validateLayout(config);
      assert(
        result.valid === false,
        'Test 18: validateLayout returns invalid for board below minimum size'
      );
      assert(
        result.errors.length > 0,
        'Test 19: validateLayout returns errors for board below minimum size'
      );
    } catch (error) {
      results.push({ name: 'Test 18-19: validateLayout invalid board', passed: false, error: error.message });
      failCount++;
    }

    // Test 12: validateLayout with null configuration
    try {
      const optimizer = new LayoutOptimizer();
      const result = optimizer.validateLayout(null);
      assert(
        result.valid === false,
        'Test 20: validateLayout returns invalid for null configuration'
      );
      assert(
        result.errors.length > 0,
        'Test 21: validateLayout returns errors for null configuration'
      );
    } catch (error) {
      results.push({ name: 'Test 20-21: validateLayout null', passed: false, error: error.message });
      failCount++;
    }

    // Test 13: validateLayout with invalid layout strategy
    try {
      const optimizer = new LayoutOptimizer();
      const config = {
        boardSize: { width: 400, height: 400 },
        boardPosition: { x: 10, y: 10, width: 400, height: 400, transform: '', zIndex: 1 },
        elementPositions: new Map(),
        layoutStrategy: 'invalid-strategy',
        requiresScrolling: false,
        scrollContainers: []
      };
      const result = optimizer.validateLayout(config);
      assert(
        result.valid === false,
        'Test 22: validateLayout returns invalid for invalid layout strategy'
      );
    } catch (error) {
      results.push({ name: 'Test 22: validateLayout invalid strategy', passed: false, error: error.message });
      failCount++;
    }

    // Test 14: calculateOptimalLayout with valid analysis
    try {
      const optimizer = new LayoutOptimizer();
      const analysisResult = {
        viewportWidth: 1920,
        viewportHeight: 1080,
        invisibleElements: []
      };
      const layout = optimizer.calculateOptimalLayout(analysisResult);
      assert(
        layout !== null && layout !== undefined,
        'Test 23: calculateOptimalLayout returns layout configuration'
      );
      assert(
        layout.boardSize !== undefined,
        'Test 24: calculateOptimalLayout includes board size'
      );
      assert(
        layout.layoutStrategy !== undefined,
        'Test 25: calculateOptimalLayout includes layout strategy'
      );
    } catch (error) {
      results.push({ name: 'Test 23-25: calculateOptimalLayout', passed: false, error: error.message });
      failCount++;
    }

    // Test 15: calculateOptimalLayout with null analysis
    try {
      const optimizer = new LayoutOptimizer();
      assertThrows(
        () => optimizer.calculateOptimalLayout(null),
        'Test 26: calculateOptimalLayout throws error for null analysis'
      );
    } catch (error) {
      results.push({ name: 'Test 26: calculateOptimalLayout null', passed: false, error: error.message });
      failCount++;
    }

    // Test 16: calculateOptimalLayout with invalid viewport
    try {
      const optimizer = new LayoutOptimizer();
      assertThrows(
        () => optimizer.calculateOptimalLayout({
          viewportWidth: -100,
          viewportHeight: 1080,
          invisibleElements: []
        }),
        'Test 27: calculateOptimalLayout throws error for invalid viewport'
      );
    } catch (error) {
      results.push({ name: 'Test 27: calculateOptimalLayout invalid viewport', passed: false, error: error.message });
      failCount++;
    }

    // Test 17: Board size maximization
    try {
      const optimizer = new LayoutOptimizer({ prioritizeBoard: true });
      const boardSize = optimizer.calculateBoardSize(
        { width: 1000, height: 1000 },
        []
      );
      assert(
        boardSize.width > 280,
        'Test 28: Board size is maximized when space is available'
      );
    } catch (error) {
      results.push({ name: 'Test 28: Board size maximization', passed: false, error: error.message });
      failCount++;
    }

    // Test 18: Minimum spacing enforcement
    try {
      const optimizer = new LayoutOptimizer({ spacing: 16 });
      assert(
        optimizer.getConfig('spacing') >= 16,
        'Test 29: Minimum spacing of 16px is enforced'
      );
    } catch (error) {
      results.push({ name: 'Test 29: Minimum spacing', passed: false, error: error.message });
      failCount++;
    }

    // Display results
    const resultsDiv = document.getElementById('results');
    let html = '<h2>Test Results</h2>';
    
    results.forEach(result => {
      const className = result.passed ? 'pass' : 'fail';
      const icon = result.passed ? '✓' : '✗';
      const errorMsg = result.error ? ` - Error: ${result.error}` : '';
      html += `<div class="test-item ${className}">${icon} ${result.name}${errorMsg}</div>`;
    });

    const summaryClass = failCount === 0 ? 'all-pass' : 'has-fail';
    html += `<div class="summary ${summaryClass}">`;
    html += `<div>Total Tests: ${passCount + failCount}</div>`;
    html += `<div>Passed: ${passCount}</div>`;
    html += `<div>Failed: ${failCount}</div>`;
    html += `</div>`;

    resultsDiv.innerHTML = html;

    // Log to console
    console.log('\n=== Test Summary ===');
    console.log(`Passed: ${passCount}`);
    console.log(`Failed: ${failCount}`);
    console.log(`Total: ${passCount + failCount}`);
  </script>
</body>
</html>
